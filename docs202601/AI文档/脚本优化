我需要用unity写一个做菜挣钱的2d游戏，我们扮演的是一个地摊摊主，主界面是一张桌布上面有若干厨具：菜刀，砧板，锅，烤箱......（种类可以参考胡闹厨房），
摊位上有四个顾客会显示出自己想吃的菜，后续的顾客显示xx人在排队。我们需要做出这四个顾客想吃的菜，只能从第一个顾客的菜开始上菜，但是可以把后续顾客的菜
提前做好，以便第一个顾客的菜上完之后可以马上上第二个顾客的菜。第一个顾客拿到自己的菜之后会支付相应的金币，并且根据菜品的评分来给出好评或者差评，
我们做菜是根据食谱来的，我们只能制作自己有的食谱里面的菜，食谱需要定义做菜的详细步骤，包括加哪些调料，需要哪些食材制作出来的。使用挣的钱我们可以去买各种不同的小摊车
，不同的车上面搭载不同的厨具，有不同的载重，食材也有自己的重量，所以采购食材的时候需要充分考虑车子装不装得下。我们每一天的摆摊时间可以是8-24点，你可以随时选择收摊
但是收摊之后当天无法继续摆摊，游戏里一天的实际差不多为实际时间的15分钟。我们可以随时查看历史流水的折线图，也可以随时查看食谱，通过手机进行一些基本的操作，也可以随时查看
当地的基本地图，通过地图我们可以去各种场所，比如说商店（购买食材，菜谱），钓鱼场（钓鱼，获得稀有鱼类的方式），家（回家，家里会有各种交互可以做）。
请你设计一个扩展性强的，游戏系统。给出模块之间的关系。将这个游戏拆分成很细很明确的需求（包括需要的美术资源，需要哪些功能性脚本），分条列出，需求之间的依赖性尽可能小。


你生成的模块关系：
graph TD
    A[核心游戏管理器] --> B[场景管理模块]
    A --> C[玩家数据模块]
    A --> D[烹饪系统模块]
    A --> E[顾客系统模块]
    A --> F[经济系统模块]
    A --> G[时间系统模块]
    A --> H[载具/摊位模块]
    A --> I[地图探索模块]
    A --> J[UI交互模块]
    
    D --> D1[食谱子系统]
    D --> D2[厨具/食材子系统]
    D --> D3[烹饪步骤子系统]
    
    E --> E1[顾客生成子系统]
    E --> E2[订单显示子系统]
    E --> E3[评价/支付子系统]
    
    F --> F1[金币管理子系统]
    F --> F2[流水统计子系统]
    
    I --> I1[场景跳转子系统]
    I --> I2[场所交互子系统]
    
    J --> J1[主界面UI]
    J --> J2[订单UI]
    J --> J3[数据统计UI]
    J --> J4[地图/场所UI]


现在你已经列出了如下需求。


一、美术资源需求（逐条列出）
时间显示 UI 面板（2D Sprite/UI Image）
倒计时进度条（2D Sprite/UI Slider）
食谱图标（每个菜品 1 个 2D Sprite）
食谱详情面板 UI（2D Sprite/UI Image）
烹饪步骤示意图（每个步骤 1 张 2D Sprite，如 “切菜”“下锅”）
厨具 Sprite（菜刀、砧板、锅、烤箱等，每个厨具 1-2 个 Sprite）
食材 Sprite（蔬菜、肉类、调料、鱼类等，每个食材 1 个 Sprite）
食材库存 UI 面板（2D Sprite/UI Image）
烹饪步骤进度 UI（2D Sprite/UI Slider）
菜品成功 / 失败提示 Sprite（2D）
成品菜品展示 Sprite（每个菜品 1 个 Sprite）
顾客形象 Sprite（至少 4 种不同顾客，2D）
排队人数显示 UI（2D Sprite/UI Text）
订单面板 UI（2D Sprite/UI Image）
订单优先级标识 Sprite（如 “1st” 标记，2D）
超时警告 Sprite（2D，如红色感叹号）
好评 / 差评 Sprite（2D，如笑脸 / 哭脸）
金币获取提示 Sprite（2D，如金币图标 + 数字）
金币图标 Sprite（2D）
金币不足提示 Sprite（2D，如红色叉号）
折线图 UI 面板（2D Sprite/UI Image）
流水详情 UI 面板（2D Sprite/UI Image）
不同载具 Sprite（如小推车、三轮车、餐车等，2D）
摊位桌布 Sprite（不同载具对应不同桌布，2D）
载重提示 UI（2D Sprite/UI Text）
2D 地图底图 Sprite
场所标记 Sprite（商店、钓鱼场、家、摆摊点，2D）
场景过渡遮罩 Sprite（2D）
商店场景 Sprite（2D 背景、货架、NPC）
钓鱼场场景 Sprite（2D 背景、鱼竿、水面特效）
家场景 Sprite（2D 背景、家具、交互点标记）
钓鱼小游戏 UI（进度条、按键提示，2D）
主界面 UI 面板（2D Sprite/UI Image）
手机 UI 外壳 Sprite（2D）
通用弹窗背景 Sprite（2D）
按钮 Sprite（摆摊 / 收摊 / 地图 / 食谱等，含常态 / 按下 / 禁用状态）
二、代码脚本需求（逐条列出）
GameManager.cs（单例，核心管理器，全局游戏状态 / 模块生命周期管理）
GameEventSystem.cs（事件中心，解耦模块通信）
SaveLoadSystem.cs（存档 / 读档逻辑）
PlayerData.cs（玩家数据模型，可序列化）
PlayerDataManager.cs（玩家数据增删改查逻辑）
GameTimeSystem.cs（时间计算、流速控制）
TimeUIManager.cs（时间 UI 更新逻辑）
Recipe.cs（食谱数据模型，可序列化）
RecipeManager.cs（食谱解锁、查询、加载逻辑）
RecipeUIManager.cs（食谱查看 UI 交互）
KitchenTool.cs（厨具数据模型）
Ingredient.cs（食材数据模型）
KitchenToolManager.cs（厨具管理逻辑）
IngredientManager.cs（食材采购、消耗、库存管理）
CookingStep.cs（单一步骤数据模型）
CookingSystem.cs（烹饪流程控制、步骤执行）
Dish.cs（成品菜品数据模型，关联顾客订单）
DishStorage.cs（已完成菜品暂存管理）
Customer.cs（顾客数据模型，含订单、等待时间）
CustomerSpawner.cs（顾客生成、排队人数更新）
Order.cs（订单数据模型，关联顾客和菜品）
OrderUIManager.cs（订单 UI 展示、状态更新）
PaymentSystem.cs（金币结算逻辑）
EvaluationSystem.cs（评价生成、影响逻辑）
GoldManager.cs（金币增删改查）
GoldUIManager.cs（金币 UI 更新）
TransactionRecord.cs（流水数据模型）
TransactionManager.cs（流水记录、统计）
ChartSystem.cs（折线图生成、展示逻辑）
Vehicle.cs（载具数据模型）
VehicleManager.cs（载具购买、切换、载重计算）
StallDisplay.cs（摊位厨具展示更新）
MapSystem.cs（地图数据、场景跳转逻辑）
SceneLoader.cs（场景加载、过渡效果）
ShopSystem.cs（商店购买逻辑）
FishingGame.cs（钓鱼小游戏逻辑）
HomeSystem.cs（家的交互逻辑）
UIManager.cs（所有 UI 的统一管理）
MainUIPanel.cs（主界面 UI 交互）
PhoneUISystem.cs（手机模拟 UI 逻辑）
PopupWindow.cs（通用弹窗逻辑）
InputSystem.cs（输入适配，支持键鼠 / 触控）




假设美术资源已经完成了。


脚本开发进度如下。
二、最终脚本完成进度统计
分类	已完成	未完成	总计
核心管理器	2/2	0	2
玩家数据	4/4	0	4
时间系统	2/2	0	2
烹饪系统	7/7	0	7
顾客系统	5/5	0	5
经济系统	6/6	0	6
载具 / 摊位	3/3	0	3
地图场景	3/3	0	3
扩展玩法	3/3	0	3
UI 系统	8/8	0	8
输入系统	1/1	0	1
总计	44	0	44
详细完成清单
序号	脚本名称	状态	备注
1	GameManager.cs	✅ 完成	核心管理器
2	GameEventSystem.cs	✅ 完成	事件中心
3	SaveLoadSystem.cs	✅ 完成	存档 / 读档
4	PlayerData.cs	✅ 完成	玩家数据模型（序列化）
5	PlayerDataManager.cs	✅ 完成	玩家数据管理
6	GameTimeSystem.cs	✅ 完成	时间计算
7	TimeUIManager.cs	✅ 完成	时间 UI 更新
8	Recipe.cs	✅ 完成	食谱数据模型
9	RecipeManager.cs	✅ 完成	食谱管理
10	RecipeUIManager.cs	✅ 完成	食谱 UI 交互
11	KitchenTool.cs	✅ 完成	厨具数据模型
12	Ingredient.cs	✅ 完成	食材数据模型
13	KitchenToolManager.cs	✅ 完成	厨具管理
14	IngredientManager.cs	✅ 完成	食材管理
15	CookingStep.cs	✅ 完成	烹饪步骤模型（内嵌）
16	CookingSystem.cs	✅ 完成	烹饪流程控制（完善）
17	Dish.cs	✅ 完成	菜品数据模型
18	DishStorage.cs	✅ 完成	菜品暂存管理
19	Customer.cs	✅ 完成	顾客数据模型
20	CustomerSpawner.cs	✅ 完成	顾客生成
21	Order.cs	✅ 完成	订单数据模型
22	OrderUIManager.cs	✅ 完成	订单 UI 展示
23	PaymentSystem.cs	✅ 完成	金币结算
24	EvaluationSystem.cs	✅ 完成	评价系统
25	GoldManager.cs	✅ 完成	金币管理
26	GoldUIManager.cs	✅ 完成	金币 UI 更新
27	TransactionRecord.cs	✅ 完成	流水记录模型（内嵌）
28	TransactionManager.cs	✅ 完成	流水统计
29	ChartSystem.cs	✅ 完成	折线图生成
30	Vehicle.cs	✅ 完成	载具数据模型
31	VehicleManager.cs	✅ 完成	载具管理
32	StallDisplay.cs	✅ 完成	摊位展示
33	MapSystem.cs	✅ 完成	地图系统
34	SceneLoader.cs	✅ 完成	场景加载
35	ShopSystem.cs	✅ 完成	商店系统
36	FishingGame.cs	✅ 完成	钓鱼小游戏
37	HomeSystem.cs	✅ 完成	家的交互
38	UIManager.cs	✅ 完成	UI 统一管理
39	MainUIPanel.cs	✅ 完成	主界面 UI
40	PhoneUISystem.cs	✅ 完成	手机 UI 系统
41	PopupWindow.cs	✅ 完成	通用弹窗
42	InputSystem.cs	✅ 完成	输入适配
43	补充：CookingSystem 完善	✅ 完成	厨具选择逻辑
44	补充：PlayerData 序列化	✅ 完成	存档兼容性


仔细检查脚本里面不正确的变量，名字不一样但是意义一样的字段，简练优化一下。结合游戏逻辑优化脚本。每次优化三个脚本给出完整代码。并且输出优化进度
优化进度统计
优化轮次	优化脚本	优化状态	核心优化点总结	累计优化数	剩余待优化数
第一轮	ChartSystem.cs	✅ 完成	命名规范、空值校验、资源释放、逻辑精简	1	41
第一轮	PlayerData.cs	✅ 完成	数据结构精简、补充核心方法、序列化规范	2	40
第一轮	GameTimeSystem.cs	✅ 完成	事件解耦、时间计算优化、收摊逻辑完善	3	39
优化说明补充
命名规范统一：所有私有变量添加下划线前缀（如lineRenderer→_lineRenderer），公有变量小驼峰（如ChartBackground→chartBackground），避免 “名字不同意义相同” 的混乱；
逻辑解耦：GameTimeSystem 通过事件中心 / 委托更新 UI，不再直接依赖 UI 脚本；
边界条件处理：补充 PlayerData 的载重校验、食材增减的边界逻辑，ChartSystem 的 TryGetValue 避免键不存在异常；
资源管理：ChartSystem 新增材质释放逻辑，避免内存泄漏；
可读性提升：提取重复逻辑为独立方法（如 FilterRecentDays、CalculateMaxIncome），添加详细注释和 XML 文档。
下一轮可优化方向：TransactionManager.cs、GoldManager.cs、Vehicle.cs（统一命名规范、精简冗余逻辑、补充边界校验）。

第二轮优化说明补充
命名规范统一：
私有变量添加下划线前缀（如currentLoadWeight→_currentLoadWeight）；
公有变量 / 方法小驼峰（如maxLoadWeight保持语义清晰，符合 Unity Inspector 可读性）；
枚举 / 常量全大写 + 下划线（如TransactionType枚举语义明确，无冗余命名）。
边界条件强化：
TransactionManager：校验交易金额不为 0，过滤非收入类型数据；
GoldManager：禁止金币增减为负、金币不足时触发专属事件；
Vehicle：载重增减校验重量为正，减少后避免负数，载重不足时返回明确提示。
逻辑解耦与封装：
TransactionManager：通过GameEventSystem触发流水更新事件，不再直接调用 UI 脚本；
GoldManager：新增OnGoldChanged委托 + 全局事件，UI 仅需监听事件即可更新；
Vehicle：将载重计算（剩余载重、增减校验）封装为独立方法，外部仅需调用AddLoadWeight/ReduceLoadWeight，无需关心内部逻辑。
可读性与可维护性：
补充完整 XML 文档注释，每个方法明确入参 / 出参 / 功能；
提取重复逻辑（如InitIncomeCache/UpdateIncomeCache），减少代码冗余；
序列化优化：Vehicle新增Serialize/DeserializeLoadWeight，适配存档加载逻辑。
下一轮可优化方向
RecipeManager.cs、IngredientManager.cs、CookingSystem.cs（统一命名规范、精简食谱查询逻辑、补充食材消耗边界校验、烹饪步骤状态机优化）。